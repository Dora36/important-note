## 数据交互

`http` 所有数据请求(除websocket)对于服务器来说其实都是表单提交 只是前端的写法不同

1. 表单：最基本的 最简单的 默认可跨域
2. `ajax`：
    - 不用刷新页面 节约流量 降低服务端的压力  用户体验也好。
    - 缺点：网慢会重复提交 可让按钮禁用。
    - 默认不能跨域，需要服务器配置
3. `jsonp`：过渡，已经不常用了，解决跨域过于开放，安全性太差，只能 `get` 请求。
4. `WebSocket`：快、双向、可跨域，建议使用

Ajax|性能低|单向|跨域需配置
:---:|:---:|:---:|:---:
WebSocket|性能高|双向（双工）|默认可跨域

### 安全性：
1. 系统安全性
2. 代码安全性——校验

`GET`、`POST` 安全性完全一样，`https`才是真安全。

没有100%的安全，只能让犯罪成本更高才能更安全。


### 数据提交类型

`content-type` 属性值：

- `text/plain`：纯文本，几乎不用
- `application/x-www-form-urlencoded`：表单提交的方式，参数用&连接，提交简单数据。
- `multipart/form-data`：定界符分割各个数据(可用于文件上传)

`urlencoded` 就是 `url` 编码，格式是： 名字=值&名字=值&名字=值


## 跨域

www.baidu.com/a.html  ->   www.360.cn/1.txt

xss 攻击

### 跨域是必须的：
1. 360buy.com -> jd.com；t.sina.cn -> weibo.com
2. 调用第三方数据

### 跨域解决方法
1. 表单默认可跨域
2. `ajax` - 麻烦、安全
3. `jsonp` - 简单，有风险
4. `websocket`


## http 协议

1. `http`：容易被攻击
2. `https`：`security`   安全

### 版本
- `http1.0`：一次性连接
- `http1.1`：保持连接 等页面完全加载完后才断开  性能提升
- `http2.0`（草案）：
    - 强制 `https`
    - 自带双向通信
    - 多路复用

`RFC`，是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。

`rfc2616`：[`http`协议文件](https://tools.ietf.org/html/rfc2616)

### 交互
1. 三次握手：客户端建立连接  服务器接受  客户端请求数据  服务器返回数据
2. `http`消息(`header/body`): 消息头`header<= 32K` ；消息体`body <= 1G`

### http状态码

- 1xx：消息
- 2xx：成功
- 3xx：重定向
  - 301：永久重定向
  - 302：临时重定向
  - 304：缓存
- 4xx：请求错误（客户端）
- 5xx：服务器错误
- 6xx：扩展状态码

## `OSI` 七层交换 参考 模型

1. 物理层：物理学家、通信工程 - 材料、电压等
2. 链路层：内网寻址     ARP、ICMP
3. 网络层：外网寻址     IP
4. 传输层：通信稳定性   TCP
5. 表现层：x 统一各个网络结构
6. 会话层：x 服务器可记录状态，但实际上一直是无状态通信
7. 应用层：应用细节     HTTP、FTP、SMTP、POP3、

五层模型
1. 物理层
2. 链路层
3. 网络层
4. 传输层
5. 应用层

无状态通信

`TCP` - 传输控制协议 （对质量要求高）  eg.文件下载、聊天

  1. 保证到达：丢失重传
  2. 保证质量：错误重发
  3. 保证顺序
  
`UCP` - 用户数据报协议  对质量没绝对要求，对延迟有很高的要求  eg. IP电话、视频直播

  1. 不保证到达
  2. 不保证质量
  3. 不保证顺序

----

## 表单

### 属性

- action:  提交地址
- method:  提交方式 - GET、POST、PUT、HEADER、DELETE、也可自定义
- name:    必须加、可以重复，name相同 在服务器端就是个数组。
- sumit按钮: 提交数据

### 数据提交方法

##### GET：数据放在url里面
  - 容量有限，<= 32K
  - 数据可见（仅是表单）
  - 有缓存
  - 利于分享和收藏：在url里就有页面需要的数据，可直接分享给别人打开或收藏。

##### POST：数据放在 http-body 里面
  - 容量很大，<= 1G
  - 数据不可见
  - 不缓存
  - 没法分享和收藏

### 校验

    <form action="http://localhost/a.php" method="GET" id="form1">
      <label>
        用户名：<input type="text" name="user" value="">
      </label>
      <label>
        密码：<input type="password" name="pass">
      </label>
      <input type="submit" value="提交">
    </form>

    <script>
      1. const $ = function(...args){
        return document.querySelectorAll(...args);
      }
      2. const $ = document.querySelectorAll.bind(document);
    
      window.onload=function(){
        let oForm = $('#form1')[0];
        let oUser = document.getElementsByName('user')[0];
        oForm.onsubmit=function () {
          if(oUser.value === '') {
            alert('用户名不能为空');
            return false;
          }
        }
      }
    </script>

`jQuery Validate` 插件可用。

## Websocket
   
 websocket服务不是独立存在的，需要依赖于 `http` 服务
 
 1. 双向通信
 2. 自动跨域
 3. 性能高
 
### socket.io 第三方库

#### 安装

    npm install socket.io -D

#### 使用
 
服务端使用
 
    const http = require('http');
    const io = require('socket.io');
    
    let httpServer = http.createServer((req,res)=>{});
    httpServer.listen(8080);
    
    let wsServer = io.listen(httpServer);
    
    wsServer.on('connection',sock=>{
      //服务器接收浏览器发送过来的数据
      sock.on('aaa',function(a){
        console.log(a) //12
      });
      //服务器向浏览器发送数据
      sock.emit('serverTime',new Date().getTime());
    });
 
浏览器端使用
 
    // socket.io 自动生成的js文件
    <script src="http://localhost:8080/socket.io/socket.io.js"></script> 
    <script>
      let sock = io.connect('ws://localhost:8080/');
      //浏览器向服务器发送数据
      sock.emit('名字',参数);
      //浏览器接收服务器发送过来的数据
      sock.on('serverTime',function(date){
        console.log(date); // 获取到服务器时间
      })
    </script>
 
#### 连接状态管理

连接状态属于特殊事件，因此 `on` 的事件名是固定的。

服务端

    let wsServer = io.listen(httpServer);
    
    //客户端连接上 websocket 服务器
    wsServer.on('connection',sock=>{
      //某一个客户端服务器断开
      sock.on('disconnect',()={})
    })

客户端

    let sock = io.connect('ws://localhost:8080/');
    
    //客户端连接上 websocket 服务器
    sock.on('connect',()=>{});
    
    //websocket 服务器断开连接
    sock.on('disconnect',()=>{});

## ajax 2.0

- `formData` 控制提交数据、主要用于文件上传（可显示进度）
- `cors` 跨域

## formdata

	let data = new FormData();
	data.set('key','value');
	data.append('key','value');

### 操作

#### set(key,value) / append(key,value)

`set` 如果 `key` 值一样，会覆盖。

`append` 是追加同一个 `key` 的属性值。属性值会变成一个数组。

#### get(key) / getAll(key)

`get` 获取`key`的属性值，只能获取第一个。

`getAll` 获取`key`的所有值，数组，包含`append` 的数据 

#### delete(key)

删除属性为 `key` 的值

### 提交

#### GET 

将 `formdata` 数据处理为正常 `urlencoded` 的 `url` 编码后，按照正常路径带参数的方式提交。

与普通的 `ajax` 提交相比没有优势。

    let data = new FormData();
    data.set('user','dora');
    data.set('pass','123456');
    
    // 处理数据
    let arr = [];
    data.forEach((value,key)=>{
      arr.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
    });
    let param = arr.join('&');
    
    // 提交
    let xhr = new XMLHttpRequest();
    xhr.open('GET',`http://localhost:8080/api?${param}`,true);
    xhr.send();

#### POST

就算设置了 `Content-Type` ，也会默认按照 `multipart/form-data` 方式提交，类似于文件的提交格式。因此后台需要按照文件的处理方式处理 `post` 提交的数据。

与普通的 `ajax` 提交相比麻烦了很多。

    xhr.open('POST',`http://localhost:8080/api`,true);
    
    // 不起作用
    // xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send(data);

#### 上传文件

**获取文件信息**

`oF.value`：返回文件路径，而且是假的路径，并不是真是的路径。

`oF.files`：是个数组，含有 `name`,`type`,`size`,`lastModified` 时间等信息

    let oF = document.querySelect('#f1');
    let fileContent = oF.files;
    
    oF.value; // C:\fakepath\3.html
    oF.files; // []

**获取提交的数据**

    let data = new FormData();
    data.set('user','dora');
    data.set('pass','123456');
    
    // 提交文件数据
    Array.from(oF.files).forEach(file=>{
      data.append('f1',file);
    };

**提交到后台**

不用设置任何 `header` 属性，就会提交文件，并包含文件内容。

    let xhr = new XMLHttpRequest();
    xhr.open('POST',`http://localhost:8080/api`,true);
    xhr.send(data);

### 接收数据 (express 框架)

`formData` 的 `GET` 和 `POST` 请求，在后台接收的时候与普通 `ajax` 没有区别。

#### RESTful 接口风格

不是标准，不是协议，不是规范，只是一种风格。

确定接口的因素

1. 请求方式
2. 请求路径

因此只要请求方式不一样，请求路径就可以一样。

#### 使用

**需要安装的文件**

1. `express` 本体
2. 中间件（插件）
    - `body-parser`：接收普通 `POST` 数据
    - `multer`：接收 `POST` 文件数据


    npm i express body-parser multer -D

**服务端使用**

    const express = require('express');
    const body = require('body-parser');
    const multer = require('multer');
    
    let server = express();
    server.listen(8080);
    
    server.get('/',(req,res)=>{
      res.send('Hello Express');
    });
    
    server.post('/api',(req,res)=>{
      res.send('Hello Express');
    
      console.log(req.body); // 普通数据 {}
      console.log(req.files); // 文件数据 []
    });
    
    //任何方式请求 '/' 时执行
    server.use('/',()=>{});





