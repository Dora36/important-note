
## ajax 2.0

- `formData` 控制提交数据、主要用于文件上传（可显示进度）
- `cors` 跨域

## formdata

	let data = new FormData();
	data.set('key','value');
	data.append('key','value');

### 操作

#### set(key,value) / append(key,value)

`set` 如果 `key` 值一样，会覆盖。

`append` 是追加同一个 `key` 的属性值。属性值会变成一个数组。

#### get(key) / getAll(key)

`get` 获取`key`的属性值，只能获取第一个。

`getAll` 获取`key`的所有值，数组，包含`append` 的数据 

#### delete(key)

删除属性为 `key` 的值

### 提交

#### GET 

将 `formdata` 数据处理为正常 `urlencoded` 的 `url` 编码后，按照正常路径带参数的方式提交。

与普通的 `ajax` 提交相比没有优势。

    let data = new FormData();
    data.set('user','dora');
    data.set('pass','123456');
    
    // 处理数据
    let arr = [];
    data.forEach((value,key)=>{
      arr.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
    });
    let param = arr.join('&');
    
    // 提交
    let xhr = new XMLHttpRequest();
    xhr.open('GET',`http://localhost:8080/api?${param}`,true);
    xhr.send();

#### POST

就算设置了 `Content-Type` ，也会默认按照 `multipart/form-data` 方式提交，类似于文件的提交格式。因此后台需要按照文件的处理方式处理 `post` 提交的数据。

与普通的 `ajax` 提交相比麻烦了很多。

    xhr.open('POST',`http://localhost:8080/api`,true);
    
    // 不起作用
    // xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send(data);

#### 上传文件


**获取文件信息**

`oF.value`：返回文件路径，而且是假的路径，并不是真是的路径。

`oF.files`：是个数组，含有 `name`,`type`,`size`,`lastModified` 时间等信息
    
    <input type="file" id="f1" multiple>
    
    let oF = document.querySelect('#f1');
    let fileContent = oF.files;
    
    oF.value; // C:\fakepath\3.html
    oF.files; // []

**获取提交的数据**

    let data = new FormData();
    data.set('user','dora');
    data.set('pass','123456');
    
    // 提交文件数据
    Array.from(oF.files).forEach(file=>{
      data.append('f1',file);
    };

**提交到后台**

不用设置任何 `header` 属性，就会提交文件，并包含文件内容。

    let xhr = new XMLHttpRequest();
    xhr.open('POST',`http://localhost:8080/api`,true);
    xhr.send(data);

**上传的文件大小**

1. `http` 协议规定 `body` 数据`<1G`，因此文件也不能大于1G。
2. 如果传输大文件，可考虑用户体验。

超过 `50M` 的文件可用插件进行上传，支持断点续传之类的技术。


##### 拖拽上传文件

**事件**

- `ondragenter`：拖着东西进入
- `ondragleave`：拖着东西离开
- `ondragover`：悬停，只要鼠标没松手，就会一直触发。并且不阻止默认事件，`ondrop` 就不会触发。`return false`
- `ondrop`：松手，要阻止直接打开文件的默认事件。`return false`

### 接收数据 (express 框架)

`formData` 的 `GET` 和 `POST` 请求，在后台接收的时候与普通 `ajax` 没有区别。

#### RESTful 接口风格

不是标准，不是协议，不是规范，只是一种风格。

确定接口的因素

1. 请求方式
2. 请求路径

因此只要请求方式不一样，请求路径就可以一样。

#### 使用

**需要安装的文件**

1. `express` 本体
2. 中间件（插件）
    - `body-parser`：接收普通 `POST` 数据
    - `multer`：接收 `POST` 文件数据


    npm i express body-parser multer -D

**服务端使用**

    const express = require('express');
    const body = require('body-parser');
    const multer = require('multer');
    
    let server = express();
    server.listen(8080);
    
    server.get('/',(req,res)=>{
      res.send('Hello Express');
    });
    
    server.post('/api',(req,res)=>{
      res.send('Hello Express');
    
      console.log(req.body); // 普通数据 {}
      console.log(req.files); // 文件数据 []
    });
    
    //任何方式请求 '/' 时执行
    server.use('/',()=>{});

## CORS

网络请求没有跨域的概念，跨域是浏览器自己对请求的限制。

**解决办法**

后台配置 `Access-Control-Allow-Origin` 的 `header`。

    res.setHeader('Access-Control-Allow-Origin','*');

`*` 号代表一切域名都可访问，没有安全性可言，因此需根据请求发过来的 `origin` 进行正则判断，符合条件的可允许跨域。

    let reqOrigin = req.headers['origin'];
    if( reqOrigin=== 'null' || /^https?:\/\/(\w+\.)+test\.com/.test(reqOrigin)){
      res.setHeader('Access-Control-Allow-Origin','*');
    }

**限制**

用 `formdata` 提交数据会有 `origin` 头，而普通 `ajax` 数据提交没有 `origin` 头，因此需要自己手动配置一个限制。




















