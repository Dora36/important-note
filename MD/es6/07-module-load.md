## 浏览器加载 es6 模块

浏览器加载 ES6 模块，使用 `<script>` 标签，但是要加入 `type="module"` 属性。

```js
<script type="module" src="./module.js"></script>
```

浏览器对于带有 `type="module"` 的 `<script>`，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 `<script>` 标签的 `defer` 属性。如果网页有多个 `<script type="module">`，会按照在页面出现的顺序依次执行。

也可通过设置 `async` 属性覆盖 `defer` 默认，但此时不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。

模块脚本的注意事项：

- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
- 模块脚本自动采用严格模式，不管有没有声明 use strict。
- 模块之中，可以使用 `import` 命令加载其他模块（`.js` 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 `export` 命令输出对外接口。
- 模块之中，顶层的 `this` 关键字返回 `undefined`，而不是指向 `window`。也就是说，在模块顶层使用 `this` 关键字，是无意义的。
- 同一个模块如果加载多次，将只执行一次。

### 执行

`import` 命令是在代码运行之前的编译阶段执行的。所以 `import` 命令具有提升效果，会提升到整个模块的头部，首先执行。

```js
// a.js
console.log(222);
```

```js
// index.js
console.log(111);
import './a.js'

// script 引入 index.js 后的执行结果为：
// 222
// 111
```

所以在 `script` 的模块引用中，浏览器在编译阶段就会发送请求获取所有 `import` 的模块文件，并且在执行时，都会先执行 `import` 的模块代码，然后再执行当前文件代码。

## import 与 CommonJS 的区别

- 1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- 2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

第二个差异是因为 CommonJS 加载的是一个对象（即 `module.exports` 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 `import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。最后，`export` 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。

## nodejs 加载 es6 模块

Node.js 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。

- Node.js 要求 ES6 模块采用 `.mjs` 后缀文件名。也就是说，只要脚本文件里面使用 `import` 或者 `export` 命令，那么就必须采用 `.mjs` 后缀名。

- 如果不希望将后缀名改成 `.mjs`，可以在项目的 `package.json` 文件中，指定 `type` 字段为 `module`。一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成 `.cjs`。

总结为一句话：`.mjs` 文件总是以 ES6 模块加载，`.cjs` 文件总是以 CommonJS 模块加载，`.js` 文件的加载取决于 `package.json` 里面 `type` 字段的设置。
